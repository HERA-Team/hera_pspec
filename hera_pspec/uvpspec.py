import numpy as np
from collections import OrderedDict as odict
from hera_pspec import conversions
from hera_pspec.parameter import PSpecParam
import os
from pyuvdata import uvutils as utils


class UVPSpec(object):
    """
    Object for storing power spectra generated by hera_pspec.
    """
    def __init__(self):
        """
        A container object for storing power spectra generated by hera_pspec.
        """
        # Summary attributes
        self._Ntimes = PSpecParam("Ntimes", description="Number of unique times.", expected_type=int)
        self._Nblpairts = PSpecParam("Nblpairts", description="Total number of baseline-pair times.", expected_type=int)
        self._Nblpairs = PSpecParam("Nblpairs", description='Total number of baseline-pairs.', expected_type=int)
        self._Nspwdlys = PSpecParam("Nspwdlys", description="Total number of delay bins across all sub-bands.", expected_type=int)
        self._Nspws = PSpecParam("Nspws", description="Number of spectral windows.", expected_type=int)
        self._Ndlys = PSpecParam("Ndlys", description="Total number of delay bins.", expected_type=int)
        self._Npols = PSpecParam("Npols", description="Number of polarizations in the data.", expected_type=int)
        self._history = PSpecParam("history", description='The file history.', expected_type=str)

        # Data attributes
        desc = "Power spectrum data dictionary with spw integer as keys and values as complex ndarrays."
        self._data_array = PSpecParam("data_array", description=desc, expected_type=dict, form="(Nblpairts, Ndlys, Npols)")
        desc = "Data flag dictionary, with same shape as data_array but ndarrays are boolean. True if flagged."
        self._flag_array = PSpecParam("flag_array", description=desc, expected_type=dict, form="(Nblpairts, Ndlys, Npols)")
        desc = "Integration dictionary containing total amount of integration time (seconds) in each power spectrum " \
                "with same form as data_array except without the dlys axis."
        self._integration_array = PSpecParam("integration_array", description=desc, expected_type=dict, form="(Nblpairts, Npols)")
        self._spw_array = PSpecParam("spw_array", description="Spw integer array.", form="(Nspwdlys,)")
        self._freq_array = PSpecParam("freq_array", description="Frequency array in Hz.", form="(Nspwdlys,)")
        self._dly_array = PSpecParam("dly_array", description="Delay array in seconds.", form="(Nspwdlys,)")
        self._pol_array = PSpecParam("pol_array", description="Polarizations in data.", form="(Npols,)")
        self._lst_1_array = PSpecParam("lst_1_array", description="LST array of the first bl in the bl-pair [radians].", form="(Nblpairts,)")
        self._lst_2_array = PSpecParam("lst_2_array", description="LST array of the second bl in the bl-pair [radians].", form="(Nblpairts,)")
        self._time_1_array = PSpecParam("time_1_array", description="Time array of the first bl in the bl-pair [Julian Date].", form="(Nblpairts,)")
        self._time_1_array = PSpecParam("time_2_array", description="Time array of the second bl in the bl-pair [Julian Date].", form="(Nblpairts,)")
        self._blpair_array = PSpecParam("blpair_array", description="Baseline-pair integer for all baseline-pair times.", form="(Nblpairts,)")

        # Baseline attributes
        self._Nbls = PSpecParam("Nbls", description="Number of unique baseline integers.", expected_type=int)
        self._bl_vecs = PSpecParam("bl_vecs", description="ndarray of baseline separation vectors in the ITRF frame [meters]. To get it in ENU frame see self.get_ENU_bl_vecs().", expected_type=np.ndarray, form="(Nbls,)")
        self._bl_array = PSpecParam("bl_array", description="All unique baseline (antenna-pair) integers.", expected_type=np.ndarray, form="(Nbls,)")

        # Misc Attributes
        self._channel_width = PSpecParam("channel_width", description="width of visibility frequency channels in Hz.", expected_type=float)
        self._telescope_location = PSpecParam("telescope_location", description="telescope location in ECEF frame [meters]. To get it in Lat/Lon/Alt see pyuvdata.utils.LatLonAlt_from_XYZ().", expected_type=np.ndarray)
        self._weighting = PSpecParam("weighting", description="form of data weighting used when forming power spectra.", expected_type=str)
        self._units = PSpecParam("units", description="units of the power spectra.", expected_type=str)

    def get_data(self, key):
        """
        Slice into data_array with a specified data key in the format

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).

        Parameters
        ----------
        key : tuple, baseline-pair key

        Return
        ------
        data : complex ndarray with shape (Ntimes, Ndlys)
        """
        spw, blpairts, pol = self.key_to_indices(key)

        return self.data_array[spw][blpairts, :, pol]

    def get_flags(self, key):
        """
        Slice into flag_array with a specified data key in the format

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).

        Parameters
        ----------
        key : tuple, baseline-pair key

        Return
        ------
        data : boolean ndarray with shape (Ntimes, Ndlys)
        """
        spw, blpairts, pol = self.key_to_indices(key)

        return self.flag_array[spw][blpairts, :, pol]

    def get_integration(self, key):
        """
        Slice into integration_array with a specified data key in the format

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).

        Parameters
        ----------
        key : tuple, baseline-pair key

        Return
        ------
        data : float ndarray with shape (Ntimes,)
        """
        spw, blpairts, pol = self.key_to_indices(key)

        return self.integration_array[spw][blpairts, pol]

    def blpair_to_antnums(self, blpair):
        """
        Convert baseline-pair integer to nested tuple of antenna numbers.

        Parameters
        ----------
        blpair : i12 int
            baseline-pair integer ID

        Return
        ------
        antnums : tuple
            nested tuple containing baseline-pair antenna numbers. Ex. ((ant1, ant2), (ant3, ant4))
        """
        return _blpair_to_antnums(blpair)

    def antnums_to_blpair(self, antnums):
        """
        Convert nested tuple of antenna numbers to baseline-pair integer.

        Parameters
        ----------
        antnums : tuple
            nested tuple containing integer antenna numbers for a baseline-pair.
            Ex. ((ant1, ant2), (ant3, ant4))

        Return
        ------
        blpair : i12 integer
            baseline-pair integer
        """
        return _antnums_to_blpair(antnums)

    def bl_to_antnums(self, bl):
        """
        Convert baseline (anntenna-pair) integer to nested tuple of antenna numbers.

        Parameters
        ----------
        bl : i6 int
            baseline integer ID

        Return
        ------
        antnums : tuple
            tuple containing baseline antenna numbers. Ex. (ant1, ant2)
        """
        return _bl_to_antnums(bl)

    def antnums_to_bl(self, antnums):
        """
        Convert tuple of antenna numbers to baseline integer.

        Parameters
        ----------
        antnums : tuple
            tuple containing integer antenna numbers for a baseline.
            Ex. (ant1, ant2)

        Return
        ------
        bl : i6 integer
            baseline integer
        """
        return _antnums_to_bl(antnums)

    def blpair_to_indices(self, blpair):
        """
        Convert a baseline-pair nested tuple ((ant1, ant2), (ant3, ant4)) or
        a baseline-pair integer into indices to index the blpairts axis of data_array.

        Parameters
        ----------
        blpair : nested tuple or blpair i12 integer
        """
        # convert blpair to integer if fed as tuple
        if isinstance(blpair, tuple):
            blpair = self.antnums_to_blpair(blpair)

        return np.arange(self.Nblpairts)[np.isclose(self.blpair_array, blpair)]


    def key_to_indices(self, key):
        """
        Convert a data key into relevant slice arrays. A data key takes the form

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).
    
        Parameters
        ----------
        key : tuple, baseline-pair key

        Returns (spw, blpairts, pol)
        -------
        spw : integer
        blpairts : list of integers to apply along blpairts axis
        pol : integer
        """
        # assert key length
        assert len(key) == 3, "length of key must be 3."
        # assign key elements
        spw = key[0]
        blpair = key[1]
        pol = key[2]
        # assert types
        assert type(spw) in (int, np.int), "spw must be an integer"
        assert type(blpair) in (int, np.int, tuple), "blpair must be an integer or nested tuple"
        assert type(pol) in (np.str, str, np.int, int), "pol must be a string or integer"
        # convert blpair to int if not int
        if type(blpair) == tuple:
            blpair = self.antnums_to_blpair(blpair)
        # convert pol to int if str
        if type(pol) in (str, np.str):
            pol = polstr2num(pol)
        # check attribuets exists in data
        assert spw in self.spw_array, "spw {} not found in data".format(spw)
        assert blpair in self.blpair_array, "blpair {} not found in data".format(blpair)
        assert pol in self.pol_array, "pol {} not found in data".format(pol)
        # index polarization array
        pol = self.pol_array.tolist().index(pol)
        # index blpairts
        blpairts = self.blpair_to_indices(blpair)

        return spw, blpairts, pol

    def select(self):
        """
        """
        raise NotImplementedError

    def get_ENU_bl_vecs(self):
        """
        return baseline vector array in TOPO (ENU) frame in meters, with matched ordering of self.bl_vecs.
        """
        return uvutils.ENU_from_ECEF(self.bl_vecs + self.telescope_location, *uvutils.LatLonAlt_from_XYZ(self.telescope_location))


    def read_hdf5(self, filepath, just_meta=False, spws=None, bls=None, blpairs=None, times=None):
        """
        """
        raise NotImplementedError

        # load-in meta data


        # edit metadata given selection
        if spws is not None:
            pass

        if blpairs is not None:
            pass

        if bls is not None:
            pass

        if times is not None:
            pass

        # return if just_meta == True
        if just_meta == True:
            return

        # create empty data arrays given meta data
        self.data_array = odict()
        self.flag_array = odict()
        self.integration_array = odict()
        for i, Ndlys in enumerate(dlys):
            self.data_array[i] = np.empty((Nblpairs, Ndlys, Npols), dtype=np.complex)
            self.flag_array[i] = np.empty((Nblpairs, Ndlys, Npols), dtype=np.bool)
            self.integration_array[i] = np.empty((Nblpairs, Ndlys, Npols), dtype=np.float)

    def write_hdf5(self, filepath, overwrite=False):
        """
        """
        raise NotImplementedError

    def check(self):
        """
        Run checks for required parameters.
        """
        # check data
        assert type(self.data_array) in (dict, odict), "self.data_array must be a dictionary type"
        assert np.min(map(lambda k: self.data_array[k].dtype in (np.complex, complex, np.complex128), self.data_array.keys())), "self.data_array values must be complex type"
        # check flags
        assert type(self.flag_array) in (dict, odict), "self.flag_array must be a dictionary type"
        assert np.min(map(lambda k: self.flag_array[k].dtype in (np.bool, bool), self.flag_array.keys())), "self.flag_array values must be boolean type"
        # check integration
        assert type(self.integration_array) in (dict, odict), "self.integration_array must be a dictionary type"
        assert np.min(map(lambda k: self.integration_array[k].dtype in (np.float, float, np.float64), self.integration_array.keys())), "self.integration_array values must be float type"


def _blpair_to_antnums(blpair):
    """
    Convert baseline-pair integer to nested tuple of antenna numbers.

    Parameters
    ----------
    blpair : <i12 integer
        baseline-pair integer

    Return
    ------
    antnums : tuple
        nested tuple containing baseline-pair antenna numbers. Ex. ((ant1, ant2), (ant3, ant4))
    """
    # get antennas
    ant1 = int(np.floor(blpair / 1e9))
    ant2 = int(np.floor(blpair / 1e6 - ant1*1e3))
    ant3 = int(np.floor(blpair / 1e3 - ant1*1e6 - ant2*1e3))
    ant4 = int(np.floor(blpair - ant1*1e9 - ant2*1e6 - ant3*1e3))

    # form antnums tuple
    antnums = ((ant1, ant2), (ant3, ant4))

    return antnums

def _antnums_to_blpair(antnums):
    """
    Convert nested tuple of antenna numbers to baseline-pair integer.

    Parameters
    ----------
    antnums : tuple
        nested tuple containing integer antenna numbers for a baseline-pair.
        Ex. ((ant1, ant2), (ant3, ant4))

    Return
    ------
    blpair : <i12 integer
        baseline-pair integer
    """
    # get antennas
    ant1 = antnums[0][0]
    ant2 = antnums[0][1]
    ant3 = antnums[1][0]
    ant4 = antnums[1][1]

    # form blpair
    blpair = int(ant1*1e9 + ant2*1e6 + ant3*1e3 + ant4)

    return blpair

def _bl_to_antnums(bl):
    """
    Convert baseline integer to tuple of antenna numbers.

    Parameters
    ----------
    blpair : <i6 integer
        baseline integer

    Return
    ------
    antnums : tuple
        tuple containing baseline antenna numbers. Ex. (ant1, ant2)
    """
    # get antennas
    ant1 = int(np.floor(bl / 1e3))
    ant2 = int(np.floor(bl - ant1))

    # form antnums tuple
    antnums = (ant1, ant2)

    return antnums

def _antnums_to_bl(antnums):
    """
    Convert tuple of antenna numbers to baseline integer.

    Parameters
    ----------
    antnums : tuple
        tuple containing integer antenna numbers for a baseline.
        Ex. (ant1, ant2)

    Return
    ------
    blpair : <i6 integer
        baseline integer
    """
    # get antennas
    ant1 = antnums[0][0]
    ant2 = antnums[0][1]

    # form blpair
    blpair = int(ant1*1e3 + ant2)

    return blpair

def _conj_blpair_int(blpair):
    """
    Conjugate a baseline-pair integer

    Parameters
    ----------
    blpair : <12 int
        baseline-pair integer

    Return
    -------
    conj_blpair : <12 int
        conjugated baseline-pair integer. 
        Ex: ((ant1, ant2), (ant3, ant4)) --> ((ant3, ant4), (ant1, ant2))
    """
    antnums = _blpair_to_antnums(blpair)
    conj_blpair = _antnums_to_blpair(antnums[::-1])
    return conj_blpair


def _conj_bl_int(blpair):
    """
    Conjugate a baseline integer

    Parameters
    ----------
    blpair : i6 int
        baseline integer

    Return
    -------
    conj_bl : i6 int
        conjugated baseline integer. 
        Ex: (ant1, ant2) --> (ant2, ant1)
    """
    antnums = _bl_to_antnums(bl)
    conj_bl = _antnums_to_bl(antnums[::-1])
    return conj_bl


def _conj_blpair(blpair, which='both'):
    """
    Conjugate one or both baseline(s) in a baseline-pair
    Ex. ((ant1, ant2), (ant3, ant4)) --> ((ant2, ant1), (ant4, ant3))

    Parameters
    ----------
    blpair : <12 int
        baseline-pair int

    which : str, options=['first', 'second', 'both']
        which baseline to conjugate

    Return
    ------
    conj_blpair : <12 int
        blpair with one or both baselines conjugated
    """
    antnums = _blpair_to_antnums(blpair)
    if which == 'first':
        conj_blpair = _antnums_to_blpair((antnums[0][::-1], antnums[1]))
    elif which == 'second':
        conj_blpair = _antnums_to_blpair((antnums[0], antnums[1][::-1]))
    elif which == 'both':
        conj_blpair = _antnums_to_blpair((antnums[0][::-1], antnums[1][::-1]))
    else:
        raise ValueError("didn't recognize {}".format(which))

    return conj_blpair




