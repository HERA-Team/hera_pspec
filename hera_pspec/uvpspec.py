import numpy as np
from collections import OrderedDict as odict
from hera_pspec import conversions
from hera_pspec.parameter import PSpecParam
import os
from pyuvdata import uvutils as uvutils
import h5py
import shutil
import copy

class UVPSpec(object):
    """
    Object for storing power spectra generated by hera_pspec.
    """
    def __init__(self):
        """
        A container object for storing power spectra generated by hera_pspec.
        """
        # Summary attributes
        self._Ntimes = PSpecParam("Ntimes", description="Number of unique times.", expected_type=int)
        self._Nblpairts = PSpecParam("Nblpairts", description="Total number of baseline-pair times.", expected_type=int)
        self._Nblpairs = PSpecParam("Nblpairs", description='Total number of baseline-pairs.', expected_type=int)
        self._Nspwdlys = PSpecParam("Nspwdlys", description="Total number of delay bins across all sub-bands.", expected_type=int)
        self._Nspws = PSpecParam("Nspws", description="Number of spectral windows.", expected_type=int)
        self._Ndlys = PSpecParam("Ndlys", description="Total number of delay bins.", expected_type=int)
        self._Npols = PSpecParam("Npols", description="Number of polarizations in the data.", expected_type=int)
        self._history = PSpecParam("history", description='The file history.', expected_type=str)

        # Data attributes
        desc = "Power spectrum data dictionary with spw integer as keys and values as complex ndarrays."
        self._data_array = PSpecParam("data_array", description=desc, expected_type=dict, form="(Nblpairts, Ndlys, Npols)")
        desc = "Data flag dictionary, with same shape as data_array but ndarrays are boolean. True if flagged."
        self._flag_array = PSpecParam("flag_array", description=desc, expected_type=dict, form="(Nblpairts, Ndlys, Npols)")
        desc = "Integration dictionary containing total amount of integration time (seconds) in each power spectrum " \
                "with same form as data_array except without the dlys axis."
        self._integration_array = PSpecParam("integration_array", description=desc, expected_type=dict, form="(Nblpairts, Npols)")
        self._spw_array = PSpecParam("spw_array", description="Spw integer array.", form="(Nspwdlys,)")
        self._freq_array = PSpecParam("freq_array", description="Frequency array in Hz.", form="(Nspwdlys,)")
        self._dly_array = PSpecParam("dly_array", description="Delay array in seconds.", form="(Nspwdlys,)")
        self._pol_array = PSpecParam("pol_array", description="Polarizations in data.", form="(Npols,)")
        self._lst_1_array = PSpecParam("lst_1_array", description="LST array of the first bl in the bl-pair [radians].", form="(Nblpairts,)")
        self._lst_2_array = PSpecParam("lst_2_array", description="LST array of the second bl in the bl-pair [radians].", form="(Nblpairts,)")
        self._time_1_array = PSpecParam("time_1_array", description="Time array of the first bl in the bl-pair [Julian Date].", form="(Nblpairts,)")
        self._time_1_array = PSpecParam("time_2_array", description="Time array of the second bl in the bl-pair [Julian Date].", form="(Nblpairts,)")
        self._blpair_array = PSpecParam("blpair_array", description="Baseline-pair integer for all baseline-pair times.", form="(Nblpairts,)")

        # Baseline attributes
        self._Nbls = PSpecParam("Nbls", description="Number of unique baseline integers.", expected_type=int)
        self._bl_vecs = PSpecParam("bl_vecs", description="ndarray of baseline separation vectors in the ITRF frame [meters]. To get it in ENU frame see self.get_ENU_bl_vecs().", expected_type=np.ndarray, form="(Nbls,)")
        self._bl_array = PSpecParam("bl_array", description="All unique baseline (antenna-pair) integers.", expected_type=np.ndarray, form="(Nbls,)")

        # Misc Attributes
        self._channel_width = PSpecParam("channel_width", description="width of visibility frequency channels in Hz.", expected_type=float)
        self._telescope_location = PSpecParam("telescope_location", description="telescope location in ECEF frame [meters]. To get it in Lat/Lon/Alt see pyuvdata.utils.LatLonAlt_from_XYZ().", expected_type=np.ndarray)
        self._weighting = PSpecParam("weighting", description="form of data weighting used when forming power spectra.", expected_type=str)
        self._norm = PSpecParam("norm", description="normalization method", expected_type=str)
        self._taper = PSpecParam("taper", description='taper function applied to data before FFT"', expected_type=str)
        self._units = PSpecParam("units", description="units of the power spectra.", expected_type=str)
        self._scalar_array = PSpecParam("scalar_array", description="power spectrum scalar from pspecbeam module.", expected_type=np.ndarray, form="(Nspws, Npols)")
        self._filename1 = PSpecParam("filename1", description="filename of data from first dataset", expected_type=str)
        self._filename2 = PSpecParam("filename1", description="filename of data from second dataset", expected_type=str)
        self._tag1 = PSpecParam("tag1", description="tag of data from first dataset", expected_type=str)
        self._tag2 = PSpecParam("tag2", description="tag of data from second dataset", expected_type=str)

        # collect required parameters
        self._req_params = ["Ntimes", "Nblpairts", "Nblpairs", "Nspwdlys", "Nspws", "Ndlys", "Npols", "history",
                            "data_array", "flag_array", "integration_array", "spw_array", "freq_array", "dly_array",
                            "pol_array", "lst_1_array", "lst_2_array", "time_1_array", "time_2_array", "blpair_array",
                            "Nbls", "bl_vecs", "bl_array", "channel_width", "telescope_location", "weighting", "units"]
        self._all_params = copy.copy(self._req_params) + \
                            ["filename1", "filename2", "tag1", "tag2", "scalar_array"]
        self._immutable_params = ["Ntimes", "Nblpairts", "Nblpairs", "Nspwdlys", "Nspws", "Ndlys", "Npols", "history",
                                 "Nbls", "channel_width", "weighting", "units", "filename1", "filename2", "tag1", "tag2",
                                 "norm", "taper"]
        self._ndarrays = ["spw_array", "freq_array", "dly_array", "pol_array", "lst_1_array", 
                          "lst_2_array", "time_1_array", "time_2_array", "blpair_array",
                          "bl_vecs", "bl_array", "telescope_location", "scalar_array"]
        self._dicts = ["data_array", "flag_array", "integration_array"]
        self._non_dicts = sorted(set(self._all_params) - set(self._dicts))

    def get_data(self, key):
        """
        Slice into data_array with a specified data key in the format

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).

        Parameters
        ----------
        key : tuple, baseline-pair key

        Return
        ------
        data : complex ndarray with shape (Ntimes, Ndlys)
        """
        spw, blpairts, pol = self.key_to_indices(key)

        return self.data_array[spw][blpairts, :, pol]

    def get_flags(self, key):
        """
        Slice into flag_array with a specified data key in the format

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).

        Parameters
        ----------
        key : tuple, baseline-pair key

        Return
        ------
        data : boolean ndarray with shape (Ntimes, Ndlys)
        """
        spw, blpairts, pol = self.key_to_indices(key)

        return self.flag_array[spw][blpairts, :, pol]

    def get_integrations(self, key):
        """
        Slice into integration_array with a specified data key in the format

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).

        Parameters
        ----------
        key : tuple, baseline-pair key

        Return
        ------
        data : float ndarray with shape (Ntimes,)
        """
        spw, blpairts, pol = self.key_to_indices(key)

        return self.integration_array[spw][blpairts, pol]

    def blpair_to_antnums(self, blpair):
        """
        Convert baseline-pair integer to nested tuple of antenna numbers.

        Parameters
        ----------
        blpair : i12 int
            baseline-pair integer ID

        Return
        ------
        antnums : tuple
            nested tuple containing baseline-pair antenna numbers. Ex. ((ant1, ant2), (ant3, ant4))
        """
        return _blpair_to_antnums(blpair)

    def antnums_to_blpair(self, antnums):
        """
        Convert nested tuple of antenna numbers to baseline-pair integer.

        Parameters
        ----------
        antnums : tuple
            nested tuple containing integer antenna numbers for a baseline-pair.
            Ex. ((ant1, ant2), (ant3, ant4))

        Return
        ------
        blpair : i12 integer
            baseline-pair integer
        """
        return _antnums_to_blpair(antnums)

    def bl_to_antnums(self, bl):
        """
        Convert baseline (anntenna-pair) integer to nested tuple of antenna numbers.

        Parameters
        ----------
        bl : i6 int
            baseline integer ID

        Return
        ------
        antnums : tuple
            tuple containing baseline antenna numbers. Ex. (ant1, ant2)
        """
        return _bl_to_antnums(bl)

    def antnums_to_bl(self, antnums):
        """
        Convert tuple of antenna numbers to baseline integer.

        Parameters
        ----------
        antnums : tuple
            tuple containing integer antenna numbers for a baseline.
            Ex. (ant1, ant2)

        Return
        ------
        bl : i6 integer
            baseline integer
        """
        return _antnums_to_bl(antnums)

    def blpair_to_indices(self, blpair):
        """
        Convert a baseline-pair nested tuple ((ant1, ant2), (ant3, ant4)) or
        a baseline-pair integer into indices to index the blpairts axis of data_array.

        Parameters
        ----------
        blpair : nested tuple or blpair i12 integer
        """
        # convert blpair to integer if fed as tuple
        if isinstance(blpair, tuple):
            blpair = self.antnums_to_blpair(blpair)

        return np.arange(self.Nblpairts)[self.blpair_array == blpair]

    def spw_to_indices(self, spw):
        """
        Convert a spectral window integer into a list of indices to index
        into the spwdlys axis of dly_array and/or freq_array.

        Parameters
        ----------
        spw : int, spectral window index
        """
        return np.arange(self.Nspwdlys)[self.spw_array == spw]

    def pol_to_index(self, pol):
        """
        Map a polarization integer or str to its index in pol_array

        Parameters
        ----------
        pol : str or int, polarization string (ex. 'XX') or integer (ex. -5)

        Returns
        -------
        index : int, index of pol in pol_array
        """
        # convert pol to int if str
        if type(pol) in (str, np.str):
            pol = uvutils.polstr2num(pol)

        index = self.pol_array.tolist().index(pol)
        return index

    def key_to_indices(self, key):
        """
        Convert a data key into relevant slice arrays. A data key takes the form

        (spw, ((ant1, ant2), (ant3, ant4)), pol)

        or

        (spw, blpair-integer, pol)

        where spw is the spectral window integer, ant1 etc. are integers, 
        and pol is either a polarization string (ex. 'XX') or integer (ex. -5).
    
        Parameters
        ----------
        key : tuple, baseline-pair key

        Returns (spw, blpairts, pol)
        -------
        spw : integer
        blpairts : list of integers to apply along blpairts axis
        pol : integer
        """
        # assert key length
        assert len(key) == 3, "length of key must be 3."
        # assign key elements
        spw = key[0]
        blpair = key[1]
        pol = key[2]
        # assert types
        assert type(spw) in (int, np.int), "spw must be an integer"
        assert type(blpair) in (int, np.int, tuple), "blpair must be an integer or nested tuple"
        assert type(pol) in (np.str, str, np.int, int), "pol must be a string or integer"
        # convert blpair to int if not int
        if type(blpair) == tuple:
            blpair = self.antnums_to_blpair(blpair)
        # convert pol to int if str
        if type(pol) in (str, np.str):
            pol = uvutils.polstr2num(pol)
        # check attribuets exists in data
        assert spw in self.spw_array, "spw {} not found in data".format(spw)
        assert blpair in self.blpair_array, "blpair {} not found in data".format(blpair)
        assert pol in self.pol_array, "pol {} not found in data".format(pol)
        # index polarization array
        pol = self.pol_to_index(pol)
        # index blpairts
        blpairts = self.blpair_to_indices(blpair)

        return spw, blpairts, pol

    def select(self, bls=None, spws=None, times=None, blpairs=None, inplace=True):
        """
        Select function
        """
        raise NotImplementedError

    def get_ENU_bl_vecs(self):
        """
        return baseline vector array in TOPO (ENU) frame in meters, with matched ordering of self.bl_vecs.
        """
        return uvutils.ENU_from_ECEF((self.bl_vecs + self.telescope_location).T, *uvutils.LatLonAlt_from_XYZ(self.telescope_location)).T

    def read_hdf5(self, filepath, just_meta=False, spws=None, bls=None, blpairs=None, times=None):
        """
        Clear current UVPSpec object and load in data from an HDF5 file.

        Parameters
        ----------
        filepath : str, path to HDF5 file

        just_meta : boolean, read-in only metadata and no data, flags or integration arrays

        spws : NotImplemented

        bls : NotImplementedError

        blpairs : NotImplemented

        times : NotImplemented
        """
        # clear object
        self._clear()

        # open file descriptor
        with h5py.File(filepath, 'r') as f:
            # load-in meta data
            for k in f.attrs:
                if k in uvp._all_params:
                    setattr(self, f.attrs[k])

            # edit metadata given selection
            if spws is not None:
                raise NotImplementedError

            if blpairs is not None:
                raise NotImplementedError

            if bls is not None:
                raise NotImplementedError

            if times is not None:
                raise NotImplementedError

            # return if just_meta == True
            if just_meta == True:
                return

            # load in data if desired
            self.data_array = odict()
            self.flag_array = odict()
            self.integration_array = odict()
            # iterate over spectral windows
            for i in np.unique(self.spw_array):
                self.data_array[i] = f['data_spw{}'.format(i)][:]
                self.flag_array[i] = f['flag_spw{}'.format(i)][:]
                self.integration_array[i] = f['integration_spw{}'.format(i)][:]


    def write_hdf5(self, filepath, overwrite=False, run_check=True):
        """
        Write a UVPSpec object to HDF5 file.

        Parameters
        ----------
        filepath : str, filepath for output file

        overwrite : boolean, overwrite output file if it exists

        run_check : boolean, run UVPSpec check before writing to file
        """
        # check output
        if os.path.exists(filepath) and overwrite is False:
            raise IOError("{} exists, not overwriting...".format(filepath))
        elif os.path.exists(filepath) and overwrite is True:
            print "{} exists, overwriting...".format(filepath)
            os.remove(filepath)

        # run check
        if run_check:
            self.check()

        # write file
        with h5py.File(filepath, 'w') as f:
            # write meta data
            for k in uvp._non_dicts:
                if hasattr(self, k):
                    f.attrs[k] = getattr(self, k)

            # iterate over spectral windows and create datasets
            for i in np.unique(self.spw_array):
                f.create_dataset("data_spw{}".format(i), data=self.data_array[i], dtype=np.complex)
                f.create_dataset("flag_spw{}".format(i), data=self.flag_array[i], dtype=np.bool)
                f.create_dataset("integration_spw{}".format(i), data=self.integration_array[i], dtype=np.float)

    def check(self):
        """
        Run checks
        """
        # check required parameters exist
        for p in self._req_params:
            assert hasattr(self, p), "required parameter {} hasn't been defined".format(p)
        # check data
        assert type(self.data_array) in (dict, odict), "self.data_array must be a dictionary type"
        assert np.min(map(lambda k: self.data_array[k].dtype in (np.complex, complex, np.complex128), self.data_array.keys())), "self.data_array values must be complex type"
        # check flags
        assert type(self.flag_array) in (dict, odict), "self.flag_array must be a dictionary type"
        assert np.min(map(lambda k: self.flag_array[k].dtype in (np.bool, bool), self.flag_array.keys())), "self.flag_array values must be boolean type"
        # check integration
        assert type(self.integration_array) in (dict, odict), "self.integration_array must be a dictionary type"
        assert np.min(map(lambda k: self.integration_array[k].dtype in (np.float, float, np.float64), self.integration_array.keys())), "self.integration_array values must be float type"

    def _clear(self):
        """
        Clear UVPSpec of all parameters. Warning: this cannot be undone.
        """
        for p in self._all_params:
            if hasattr(self, p):
                delattr(self, p)


    def __eq__(self, other):
        """ Check equivalence between attributes of two UVPSpec objects """
        try:
            for p in self._all_params:
                if p in self._immutable_params:
                    assert getattr(self, p) == getattr(other, p)
                elif p in self._ndarrays:
                    assert np.isclose(getattr(self, p), getattr(other, p)).min()
                elif p in self._dicts:
                    for i in getattr(self, p):
                        assert np.isclose(getattr(self, p)[i], getattr(other, p)[i]).min()
        except AssertionError:
            return False

        return True

def _blpair_to_antnums(blpair):
    """
    Convert baseline-pair integer to nested tuple of antenna numbers.

    Parameters
    ----------
    blpair : <i12 integer
        baseline-pair integer

    Return
    ------
    antnums : tuple
        nested tuple containing baseline-pair antenna numbers. Ex. ((ant1, ant2), (ant3, ant4))
    """
    # get antennas
    ant1 = int(np.floor(blpair / 1e9))
    ant2 = int(np.floor(blpair / 1e6 - ant1*1e3))
    ant3 = int(np.floor(blpair / 1e3 - ant1*1e6 - ant2*1e3))
    ant4 = int(np.floor(blpair - ant1*1e9 - ant2*1e6 - ant3*1e3))

    # form antnums tuple
    antnums = ((ant1, ant2), (ant3, ant4))

    return antnums

def _antnums_to_blpair(antnums):
    """
    Convert nested tuple of antenna numbers to baseline-pair integer.

    Parameters
    ----------
    antnums : tuple
        nested tuple containing integer antenna numbers for a baseline-pair.
        Ex. ((ant1, ant2), (ant3, ant4))

    Return
    ------
    blpair : <i12 integer
        baseline-pair integer
    """
    # get antennas
    ant1 = antnums[0][0]
    ant2 = antnums[0][1]
    ant3 = antnums[1][0]
    ant4 = antnums[1][1]

    # form blpair
    blpair = int(ant1*1e9 + ant2*1e6 + ant3*1e3 + ant4)

    return blpair

def _bl_to_antnums(bl):
    """
    Convert baseline integer to tuple of antenna numbers.

    Parameters
    ----------
    blpair : <i6 integer
        baseline integer

    Return
    ------
    antnums : tuple
        tuple containing baseline antenna numbers. Ex. (ant1, ant2)
    """
    # get antennas
    ant1 = int(np.floor(bl / 1e3))
    ant2 = int(np.floor(bl - ant1*1e3))

    # form antnums tuple
    antnums = (ant1, ant2)

    return antnums

def _antnums_to_bl(antnums):
    """
    Convert tuple of antenna numbers to baseline integer.

    Parameters
    ----------
    antnums : tuple
        tuple containing integer antenna numbers for a baseline.
        Ex. (ant1, ant2)

    Return
    ------
    blpair : <i6 integer
        baseline integer
    """
    # get antennas
    ant1 = antnums[0]
    ant2 = antnums[1]

    # form blpair
    blpair = int(ant1*1e3 + ant2)

    return blpair

def _blpair_to_bls(blpair):
    """
    Convert a blpair integer or nested tuple of antenna pairs
    into a tuple of baseline integers

    Parameters
    ----------
    blpair : baseline-pair integer or nested antenna-pair tuples
    """
    # convert to antnums if fed as ints
    if isinstance(blpair, int):
        blpair = _antnums_to_blpair(blpair)

    # convert first and second baselines to baseline ints
    bl1 = _antnums_to_bl(blpair[0])
    bl2 = _antnums_to_bl(blpair[1])

    return bl1, bl2

def _conj_blpair_int(blpair):
    """
    Conjugate a baseline-pair integer

    Parameters
    ----------
    blpair : <12 int
        baseline-pair integer

    Return
    -------
    conj_blpair : <12 int
        conjugated baseline-pair integer. 
        Ex: ((ant1, ant2), (ant3, ant4)) --> ((ant3, ant4), (ant1, ant2))
    """
    antnums = _blpair_to_antnums(blpair)
    conj_blpair = _antnums_to_blpair(antnums[::-1])
    return conj_blpair


def _conj_bl_int(bl):
    """
    Conjugate a baseline integer

    Parameters
    ----------
    blpair : i6 int
        baseline integer

    Return
    -------
    conj_bl : i6 int
        conjugated baseline integer. 
        Ex: (ant1, ant2) --> (ant2, ant1)
    """
    antnums = _bl_to_antnums(bl)
    conj_bl = _antnums_to_bl(antnums[::-1])
    return conj_bl


def _conj_blpair(blpair, which='both'):
    """
    Conjugate one or both baseline(s) in a baseline-pair
    Ex. ((ant1, ant2), (ant3, ant4)) --> ((ant2, ant1), (ant4, ant3))

    Parameters
    ----------
    blpair : <12 int
        baseline-pair int

    which : str, options=['first', 'second', 'both']
        which baseline to conjugate

    Return
    ------
    conj_blpair : <12 int
        blpair with one or both baselines conjugated
    """
    antnums = _blpair_to_antnums(blpair)
    if which == 'first':
        conj_blpair = _antnums_to_blpair((antnums[0][::-1], antnums[1]))
    elif which == 'second':
        conj_blpair = _antnums_to_blpair((antnums[0], antnums[1][::-1]))
    elif which == 'both':
        conj_blpair = _antnums_to_blpair((antnums[0][::-1], antnums[1][::-1]))
    else:
        raise ValueError("didn't recognize {}".format(which))

    return conj_blpair




